{"version":3,"sources":["eventtargetinterruptsource.ts"],"names":[],"mappings":";;;;;;;;;;;;;AAAA,mBAAuC,SAAS,CAAC,CAAA;AAEjD,8BAA4B,iBAAiB,CAAC,CAAA;AAC9C,gCAA8B,mBAAmB,CAAC,CAAA;AAMlD;IAAgD,8CAAe;IAI7D,oCAAsB,MAAM,EAAY,MAAc,EAAY,aAAmB;QAJvF,iBA4CC;QAxCyD,6BAA6B,GAA7B,mBAA6B;QACnF,kBAAM,IAAI,EAAE,IAAI,CAAC,CAAC;QADE,WAAM,GAAN,MAAM,CAAA;QAAY,WAAM,GAAN,MAAM,CAAQ;QAAY,kBAAa,GAAb,aAAa,CAAM;QAH7E,aAAQ,GAA2B,IAAI,KAAK,CAAC;QAC7C,sBAAiB,GAAwB,IAAI,KAAK,CAAC;QAKzD,IAAI,IAAI,GAAG,IAAI,CAAC;QAEhB,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC,UAAS,KAAK;YACtC,IAAI,GAAG,GAAG,eAAU,CAAC,SAAS,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;YAE9C,EAAE,CAAC,CAAC,IAAI,CAAC,aAAa,GAAG,CAAC,CAAC,CAAC,CAAC;gBAC3B,GAAG,GAAG,GAAG,CAAC,YAAY,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;YAC7C,CAAC;YAED,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QAC1B,CAAC,CAAC,CAAC;QAEH,IAAI,OAAO,GAAG,UAAS,SAAc;YACnC,EAAE,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;gBAChC,MAAM,CAAC;YACT,CAAC;YACD,IAAI,IAAI,GAAG,IAAI,6BAAa,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;YAC9C,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAC9B,CAAC,CAAC;QAEF,IAAI,CAAC,QAAQ,GAAG;YACd,KAAI,CAAC,QAAQ,CAAC,OAAO,CACjB,UAAC,GAAoB,IAAO,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAC1F,CAAC,CAAC;QAEF,IAAI,CAAC,QAAQ,GAAG;YACd,KAAI,CAAC,iBAAiB,CAAC,OAAO,CAAC,UAAC,GAAiB,IAAO,GAAG,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;YAC9E,KAAI,CAAC,iBAAiB,CAAC,MAAM,GAAG,CAAC,CAAC;QACpC,CAAC,CAAC;IACJ,CAAC;IAOS,gDAAW,GAArB,UAAsB,KAAU,IAAa,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC;IAC9D,iCAAC;AAAD,CA5CA,AA4CC,CA5C+C,iCAAe,GA4C9D;AA5CY,kCAA0B,6BA4CtC,CAAA","file":"eventtargetinterruptsource.js","sourcesContent":["import {Observable, Subscription} from 'rxjs/Rx';\n\nimport {InterruptArgs} from './interruptargs';\nimport {InterruptSource} from './interruptsource';\n\n\n/*\n * An interrupt source on an EventTarget object, such as a Window or HTMLElement.\n */\nexport class EventTargetInterruptSource extends InterruptSource {\n  private eventSrc: Array<Observable<any>> = new Array;\n  private eventSubscription: Array<Subscription> = new Array;\n\n  constructor(protected target, protected events: string, protected throttleDelay = 500) {\n    super(null, null);\n\n    let self = this;\n\n    events.split(' ').forEach(function(event) {\n      let src = Observable.fromEvent(target, event);\n\n      if (self.throttleDelay > 0) {\n        src = src.throttleTime(self.throttleDelay);\n      }\n\n      self.eventSrc.push(src);\n    });\n\n    let handler = function(innerArgs: any): void {\n      if (self.filterEvent(innerArgs)) {\n        return;\n      }\n      let args = new InterruptArgs(this, innerArgs);\n      self.onInterrupt.emit(args);\n    };\n\n    this.attachFn = () => {\n      this.eventSrc.forEach(\n          (src: Observable<any>) => { self.eventSubscription.push(src.subscribe(handler)); });\n    };\n\n    this.detachFn = () => {\n      this.eventSubscription.forEach((sub: Subscription) => { sub.unsubscribe(); });\n      this.eventSubscription.length = 0;\n    };\n  }\n\n  /*\n   * Checks to see if the event should be filtered. Always returns false unless overriden.\n   * @param event - The original event object.\n   * @return True if the event should be filtered (don't cause an interrupt); otherwise, false.\n   */\n  protected filterEvent(event: any): boolean { return false; }\n}\n"],"sourceRoot":"/source/"}